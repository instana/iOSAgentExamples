// Generated by Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="InstanaAgent",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

typedef SWIFT_ENUM(NSInteger, HTTPCaptureConfig, closed) {
/// HTTP requestes & responses will be captured automatically (Default configuration)
  HTTPCaptureConfigAutomatic = 0,
/// HTTP requestes & responses must be captured manually via <code>Instana.startCapture(request)</code>
  HTTPCaptureConfigManual = 1,
/// Don’t capture any http requests or responses
  HTTPCaptureConfigNone = 2,
};

@class HTTPSize;
@class NSURLResponse;

/// Remote call markers are used to track remote calls.
SWIFT_CLASS("_TtC12InstanaAgent10HTTPMarker")
@interface HTTPMarker : NSObject
/// Invoke this method when the reponse size has been determined.
/// Note: You must make sure to trigger <code>set(responseSize:</code> before calling the finish or cancel method
/// \param responseSize Size of the response.
///
- (void)setWithResponseSize:(HTTPSize * _Nonnull)responseSize;
/// Invoke this method after the request has been completed.
/// Note: Make sure you don’t call any methods on this HTTPMarker after you called finish
/// \param response Optional URLResponse when the request has been completed.
///
/// \param error Optional Error
///
- (void)finishWithResponse:(NSURLResponse * _Nullable)response error:(NSError * _Nullable)error;
/// Invoke this method if the request has been canceled before completion.
/// Note: Make sure you don’t call more methods on this HTTPMarker after you called canceled
- (void)cancel;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




@interface HTTPMarker (SWIFT_EXTENSION(InstanaAgent))
@end

@class NSURLSessionTaskTransactionMetrics;

SWIFT_CLASS_NAMED("Size")
@interface HTTPSize : NSObject
- (nonnull instancetype)initWithHeader:(int64_t)header body:(int64_t)body bodyAfterDecoding:(int64_t)bodyAfterDecoding OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithResponse:(NSURLResponse * _Nonnull)response transactionMetrics:(NSArray<NSURLSessionTaskTransactionMetrics *> * _Nullable)transactionMetrics;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Root object for the Instana agent.
/// important:
/// Before using any of Instana’s features, it is necessary to invoke one of its setup methods.
SWIFT_CLASS("_TtC12InstanaAgent7Instana")
@interface Instana : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@class NSRegularExpression;
@class NSURLSession;

@interface Instana (SWIFT_EXTENSION(InstanaAgent))
/// Optional reporting URL used for on-premises Instana backend installations.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSURL * _Nullable reportingURL;)
+ (NSURL * _Nullable)reportingURL SWIFT_WARN_UNUSED_RESULT;
/// Instana key identifying your application.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nullable key;)
+ (NSString * _Nullable)key SWIFT_WARN_UNUSED_RESULT;
/// The current session id of this active Instana agent.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nullable sessionID;)
+ (NSString * _Nullable)sessionID SWIFT_WARN_UNUSED_RESULT;
/// Configures and sets up the Instana agent with the default configuration.
/// note:
/// Should be called only once, as soon as posible. Preferably in <code>application(_:, didFinishLaunchingWithOptions:)</code>
/// <ul>
///   <li>
///     HTTP sessions will be captured automatically by default
///   </li>
/// </ul>
/// \param key Instana key to identify your application.
///
/// \param reportingURL Reporting URL for the Instana backend.
///
+ (void)setupWithKey:(NSString * _Nonnull)key reportingURL:(NSURL * _Nonnull)reportingURL;
/// Configures and sets up the Instana agent with a custom HTTP capture configuration.
/// note:
/// Should be called only once, as soon as posible. Preferably in <code>application(_:, didFinishLaunchingWithOptions:)</code>
/// \param key Instana key to identify your application.
///
/// \param reportingURL Reporting URL for the Instana backend.
///
/// \param httpCaptureConfig HTTP monitoring configuration to set the capture behavior (automatic, manual or none) http requests & responses
///
+ (void)setupWithKey:(NSString * _Nonnull)key reportingURL:(NSURL * _Nonnull)reportingURL httpCaptureConfig:(enum HTTPCaptureConfig)httpCaptureConfig;
/// Use this method to manually monitor http requests.
/// Start the capture of the http session before using the URLRequest in a URLSession (you can pass a viewName optionally as a second):
/// \code
/// let marker = Instana.startCapture(urlRequest)
///
/// \endcodeFinish the marker with the URLResponse and an optional error when the request has been completed
/// \code
/// marker.finish(response: response, error: error)
///
/// \endcodeFull example:
/// \code
/// let marker = Instana.startCapture(request)
/// URLSession.shared.dataTask(with: request) { data, response, error in
///     marker.finish(response: response, error: error)
/// }.resume()
///
/// \endcodeYou can also capture the HTTP response size manually via the URLSessionDelegate. Like the following:
/// \code
///   func urlSession(_ session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics) {
///         guard let response = task.response else { return }
///         marker.set(responseSize: HTTPMarker.Size(response: response, transactionMetrics: metrics.transactionMetrics))
///   }
///
/// \endcode\param request URLRequest to capture.
///
/// \param viewName Optional name of the visible view related to this request
///
///
/// returns:
/// HTTP marker to set the response size, finish state or error when the request has been completed.
+ (HTTPMarker * _Nonnull)startCapture:(NSURLRequest * _Nonnull)request viewName:(NSString * _Nullable)viewName SWIFT_WARN_UNUSED_RESULT;
/// Ignore HTTP monitoring for the given URLs
/// \param urls URLs that will ignored from the Instana monitoring
///
+ (void)setIgnoreWithUrls:(NSArray<NSURL *> * _Nonnull)urls;
/// Ignore HTTP monitoring for URLs that match with the given regular expressions
/// \param regex URLs that match with the given regular expressions will be ignored from monitoring
///
+ (void)setIgnoreURLsMatching:(NSArray<NSRegularExpression *> * _Nonnull)regex;
/// Ignore HTTP monitoring for given URLSession
/// \param session URLSession to ignore from HTTP monitoring
///
+ (void)ignore:(NSURLSession * _Nonnull)session;
/// Meta data information that will be attached to each transmitted data (beacon).
/// Consider using this to track UI configuration values, settings, feature flags… any additional context that might be useful for analysis.
/// \param value An arbitrary String typed value
///
/// \param key The key (String) to store the custom meta value
///
+ (void)setMetaWithValue:(NSString * _Nonnull)value key:(NSString * _Nonnull)key;
/// User-specific information
/// This information can optionally be sent with data transmitted to Instana.
/// It can then be used to unlock additional capabilities such as:
/// calculate the number of users affected by errors,
/// to filter data for specific users and
/// to see which user initiated a page load.
/// Note: By default, Instana will not associate any user-identifiable information to beacons.
/// Please be aware of the respective data protection laws when choosing to do so.
/// We generally recommend identification of users via a user ID.
/// For Instana this is a completely transparent string that is only used to calculate certain metrics.
/// Name and email can also be used to have access to more filters and a more pleasant presentation of user information.
/// \param id Unique identifier for the user
///
/// \param email User’s email address
///
/// \param name User’s full name
///
+ (void)setUserWithId:(NSString * _Nonnull)id email:(NSString * _Nullable)email name:(NSString * _Nullable)name;
/// Set the current visible view represented by a custom name.
/// This name will be attached to all monitored beacons until you call <code>setView</code> again with another name
/// The name should be unique and not too technical or generic (not just like <code>WebViewController</code>)
/// Consider something like: <code>WebView: Privacy policy</code>
/// You should call this method in <code>viewDidAppear</code>
/// \param name The name of the current visible view
///
+ (void)setViewWithName:(NSString * _Nonnull)name;
@end









#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
